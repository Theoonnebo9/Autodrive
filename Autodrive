-- Variables
local PlayerChar = STATS.STAT_GET_INT(g_util.joaat("MPPLY_LAST_MP_CHAR"));
local PlayerPed =  PLAYER.GET_PLAYER_PED(PLAYER.PLAYER_ID());
local root = MISC.GET_APPDATA_PATH("Cherax", "Lua")


-- Functions

function autodrive(value)
    autodrivetog = value
end
--Auto Drive
function driveWaypoint()
    local vehicle = PED.GET_VEHICLE_PED_IS_IN(PlayerPed, false)
    blip = UI.GET_FIRST_BLIP_INFO_ID(8)
    if UI.DOES_BLIP_EXIST(blip) then
        local Cor = UI.GET_BLIP_INFO_ID_COORD(blip)
        local direction = (Cor - ENTITY.GET_ENTITY_COORDS(vehicle)):normalized()
        local distance = #(Cor - ENTITY.GET_ENTITY_COORDS(vehicle))

        g_gui.add_toast("Calculating route...", 3000)
        local route = findPath(ENTITY.GET_ENTITY_COORDS(vehicle), Cor)
        if route then
            for i, pos in ipairs(route) do
                if distance <= 5 then
                    break
                end

                -- Check for obstacles along the way
                local collision, _, _, _, hitEntity = WORLDPROBE.PROBE_AGAINST_ENTITY(pos, vehicle, false, -1)
                if collision == 1 and hitEntity ~= vehicle then
                    g_gui.add_toast("Avoiding obstacle...", 3000)
                    local newCor = pos + (pos - ENTITY.GET_ENTITY_COORDS(hitEntity)):normalized() * 10
                    TASK.TASK_VEHICLE_DRIVE_TO_COORD_LONGRANGE(PlayerPed, vehicle, newCor.x, newCor.y, pos.z, 100, 1074528293, 5)
                    distance = 0
                else
                    TASK.TASK_VEHICLE_DRIVE_TO_COORD_LONGRANGE(PlayerPed, vehicle, pos.x, pos.y, pos.z, 100, 1074528293, 5)
                    distance = #(Cor - ENTITY.GET_ENTITY_COORDS(vehicle))
                end

                g_util.yield(200)
            end

            g_gui.add_toast("Destination reached.", 3000)
        else
            g_gui.add_toast("Unable to find route to destination.", 3000)
        end
    else
        g_gui.add_toast("Set a waypoint first!", 3000)
    end
end
-- Pathfind
function findPath(start, goal)
    local closedSet = {}
    local openSet = {}
    local obstacleSet = {}
    openSet[start] = start
    local cameFrom = {}
    local gScore = {}
    local speedMap = {}
    gScore[start] = 0
    speedMap[start] = getVehicleMaxSpeed()
    local fScore = {}
    fScore[start] = heuristic(start, goal)

    while not is_empty(openSet) do
        local current = get_lowest_f(openSet, fScore)
        if current == goal then
            return reconstruct_path(cameFrom, current)
        end

        openSet[current] = nil
        closedSet[current] = current
        local neighbors = get_neighbors(current)

        for _, neighbor in ipairs(neighbors) do
            if closedSet[neighbor] then
                goto skip
            end

            local tentative_gScore = gScore[current] + distance(current, neighbor)
            local obstacleDetected
            local speed = getVehicleMaxSpeed()

            for obstacle in ipairs(obstacleSet) do
                if not obstacleDetected then
                    local collision, _, _, _, _ = WORLDPROBE.PROBE_AGAINST_ENTITY(neighbor, obstacle, false, -1)
                    if collision == 1 then
                        obstacleDetected = true
                    end
                end
            end

            if obstacleDetected then
                table.insert(obstacleSet, neighbor)
                speed = 0
            else
                local limitedSpeed = limitSpeed(current, neighbor, getVehicleMaxSpeed())
                if limitedSpeed < speed then
                    speed = limitedSpeed
                end
            end

            local hScore = heuristic(neighbor, goal)
            local f = tentative_gScore + (hScore / speed) + obstacleCost(obstacleSet, neighbor) -- Obstacle cost is a function that returns the cost of obstacles between current and neighbor.

            if not openSet[neighbor] or f < fScore[neighbor] then
                cameFrom[neighbor] = current
                gScore[neighbor] = tentative_gScore
                fScore[neighbor] = f
                speedMap[neighbor] = speed
                openSet[neighbor] = neighbor
            end
            ::skip::
        end
    end

    return nil
end




g_lua.register()
g_hooking.register_D3D_hook(myD3DHook)

while g_isRunning do
    if waypointcheck then
        if not UI.DOES_BLIP_EXIST(blip) then
            local vehicle = PED.GET_VEHICLE_PED_IS_IN(PlayerPed, false)
            VEHICLE.SET_VEHICLE_FORWARD_SPEED(vehicle, 0)
            PED.CLEAR_PED_TASKS_IMMEDIATELY(PlayerPed)
            g_gui.add_toast("Destination Reached.",5000)
            waypointcheck = false
        end
    end
    g_util.yield(100)
end
g_lua.unregister()
