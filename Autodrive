-- Variables
local PlayerChar = STATS.STAT_GET_INT(g_util.joaat("MPPLY_LAST_MP_CHAR"))
local PlayerPed = PLAYER.GET_PLAYER_PED(PLAYER.PLAYER_ID())
local root = MISC.GET_APPDATA_PATH("Cherax", "Lua")
local path = {} -- initialize empty path

-- Functions
function autodrive(value)
    autodrivetog = value
end

-- Autodrive
function vector3(x, y, z)
    return { x = x, y = y, z = z }
end

local destination = vector3(-999.0, -999.0, -999.0) -- initialize destination to an invalid point

-- Constants (Adjust as needed)
local turning_radius = 5.0
local braking_distance = 10.0
local max_speed = 30.0 -- m/s
local max_steering_angle = 30.0 -- degrees

function calculate_distance(a, b)
    local dx = b.x - a.x
    local dy = b.y - a.y
    local dist = math.sqrt(dx * dx + dy * dy)
    return dist
end

function calculate_angle(a, b)
    local dot_product = a.x * b.x + a.y * b.y
    local magnitude_a = math.sqrt(a.x * a.x + a.y * a.y)
    local magnitude_b = math.sqrt(b.x * b.x + b.y * b.y)
    local angle = math.acos(dot_product / (magnitude_a * magnitude_b))
    return angle * (180 / math.pi) -- convert angle to degrees
end

function calculate_direction(a, b)
    local dx = b.x - a.x
    local dy = b.y - a.y
    local angle = math.atan2(dy, dx)
    local direction = angle * (180 / math.pi)
    return direction
end

function calculate_path(start, goal)
    local visited_set = {} -- set of nodes already evaluated
    local open_set = { start } -- set of tentative nodes to be evaluated
    local came_from = {} -- the map of navigated nodes
    local g_score = { [start] = 0 } -- cost of getting to start node
    local f_score = { [start] = calculate_distance(start, goal) } -- estimated total cost from start to goal

    while next(open_set) ~= nil do
        -- find the node with the lowest f_score
        local current_node = nil
        local lowest_f_score = math.huge
        for node in pairs(open_set) do
            if f_score[node] < lowest_f_score then
                current_node = node
                lowest_f_score = f_score[node]
            end
        end

        -- if we found the goal, return the path
        if current_node == goal then
            return reconstruct_path(came_from, goal)
        end

        -- remove the current node from the open set
        open_set[current_node] = nil

        -- add the current node to the visited set
        visited_set[current_node] = true

        -- examine each neighbor of the current node
        for _, neighbor in ipairs(get_neighbors(current_node)) do
            if not visited_set[neighbor] then
                local tentative_g_score = g_score[current_node] + calculate_distance(current_node, neighbor)

                if not open_set[neighbor] or tentative_g_score < g_score[neighbor] then
                    -- this path to neighbor is better than any previous one
                    came_from[neighbor] = current_node
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = g_score[neighbor] + calculate_distance(neighbor, goal)
                    if not open_set[neighbor] then
                        -- discovered a new node, add it to the open set
                        open_set[neighbor] = true
                    end
                end
            end
        end
    end

    -- no valid path found
    return nil
end

function get_neighbors(node)
    -- implement your logic here to return the valid neighbors for a given node
    -- example: return { vector3(node.x + 1, node.y, node.z), vector3(node.x, node.y + 1, node.z) }
end

function reconstruct_path(came_from, current_node)
    -- implement your logic here to reconstruct the path based on the came_from map
    -- example: local total_path = { current_node }
    --          while came_from[current_node] do
    --              current_node = came_from[current_node]
    --              table.insert(total_path, 1, current_node)
    --          end
    --          return total_path
end

-- Main Loop
while true do
    local player_position = ENTITY.GET_ENTITY_COORDS(PlayerPed, true)
    local current_speed = ENTITY.GET_ENTITY_SPEED(PlayerPed)

    if autodrivetog then
        if calculate_distance(player_position, destination) > braking_distance then
            local angle_to_destination = calculate_angle(player_position, destination)
            local steering_angle = math.min(angle_to_destination, max_steering_angle)
            local direction = calculate_direction(player_position, destination)

            -- adjust steering angle based on speed
            if current_speed > max_speed / 2 then
                steering_angle = steering_angle * (max_speed / current_speed)
            end

            -- calculate the turning radius based on the steering angle
            local turning_radius = turning_radius * (max_steering_angle / steering_angle)

            -- calculate the next position based on the turning radius and direction
            local next_position = calculate_next_position(player_position, direction, turning_radius)

            -- update the destination to the next position
            destination = next_position

            -- move the player to the next position
            ENTITY.SET_ENTITY_COORDS(PlayerPed, next_position.x, next_position.y, next_position.z, 0, 0, 0, 0)
        else
            -- reached the destination, stop autodrive
            autodrivetog = false
        end
    end

    SYSTEM.WAIT(0)
end

--Initializing and Hook
g_util.play_wav_file(root.."/resources/bruh.wav", false, false)
g_gui.add_toast("Created by Theo", 10000)
g_gui.add_toast("Welcome, ".. PLAYER.GET_PLAYER_NAME(PLAYER.PLAYER_ID()) .. " to Autodrive", 10000)
function myD3DHook()
    if g_gui.is_open() then
        g_imgui.set_next_window_size(vec2(250, 500))
        if g_imgui.begin_window("Autodrive", ImGuiWindowFlags_NoResize) then
            g_imgui.begin_child("mod_menu", vec2(), true)

            -- Autodrive
            if g_imgui.begin_menu("Auto-Drive", true) then
                g_imgui.add_button("Drive To Waypoint", vec2(300, 20), driveWaypoint)
                g_imgui.end_menu() -- Auto-Drive Options End
            end

            g_imgui.add_text("")
            g_imgui.separator() -- Misc Options End
            g_imgui.end_child()
            g_imgui.end_window() -- Mod Menu End
        end
    end
end




g_lua.register()
g_hooking.register_D3D_hook(myD3DHook)

while g_isRunning do
    if waypointcheck then
        if not UI.DOES_BLIP_EXIST(blip) then
            local vehicle = PED.GET_VEHICLE_PED_IS_IN(PlayerPed, false)
            VEHICLE.SET_VEHICLE_FORWARD_SPEED(vehicle, 0)
            PED.CLEAR_PED_TASKS_IMMEDIATELY(PlayerPed)
            g_gui.add_toast("Destination Reached.",5000)
            waypointcheck = false
        end
    end
    g_util.yield(100)
end
g_lua.unregister()
